# This file was auto-generated by Fern from our API Definition.

import datetime as dt
import typing

import pydantic as pydantic

from ....core.datetime_utils import serialize_datetime
from .post_v_2_tasks_request_data_linked_records_item_slug_or_id_of_matching_attribute_slug_or_id_of_matching_attribute_item import (
    PostV2TasksRequestDataLinkedRecordsItemSlugOrIdOfMatchingAttributeSlugOrIdOfMatchingAttributeItem,
)


class PostV2TasksRequestDataLinkedRecordsItemSlugOrIdOfMatchingAttribute(pydantic.BaseModel):
    target_object: str = pydantic.Field(
        description="A UUID or slug to identify the object that the referenced record belongs to."
    )
    slug_or_id_of_matching_attribute: typing.List[
        PostV2TasksRequestDataLinkedRecordsItemSlugOrIdOfMatchingAttributeSlugOrIdOfMatchingAttributeItem
    ] = pydantic.Field(
        alias="[slug_or_id_of_matching_attribute]",
        description='In addition to referencing records directly by record ID, you may also reference by a matching attribute of your choice. For example, if you want to add a reference to the person record with email "alice@website.com", you should pass a value with `target_object` set to `"people"` and `email_addresses` set to `[{email_address:"alice@website.com"}]`. The key should be the slug or ID of the matching attribute you would like to use and the value should be an array containing a single value of the appropriate attribute type (as specified below). Matching on multiple values is not currently supported. Matching attributes must be unique. This process is similar to how you use the `matching_attribute` query param in Attio\'s [assert endpoints](/reference/put_v2-objects-object-records).',
    )

    def json(self, **kwargs: typing.Any) -> str:
        kwargs_with_defaults: typing.Any = {"by_alias": True, "exclude_unset": True, **kwargs}
        return super().json(**kwargs_with_defaults)

    def dict(self, **kwargs: typing.Any) -> typing.Dict[str, typing.Any]:
        kwargs_with_defaults: typing.Any = {"by_alias": True, "exclude_unset": True, **kwargs}
        return super().dict(**kwargs_with_defaults)

    class Config:
        frozen = True
        
        populate_by_name = True
        json_encoders = {dt.datetime: serialize_datetime}
