# This file was auto-generated by Fern from our API Definition.

import datetime as dt
import typing

import pydantic as pydantic

from ..core.datetime_utils import serialize_datetime
from .attribute_config import AttributeConfig
from .attribute_default_value import AttributeDefaultValue
from .attribute_id import AttributeId
from .attribute_relationship import AttributeRelationship
from .attribute_type import AttributeType


class Attribute(pydantic.BaseModel):
    id: AttributeId
    title: str = pydantic.Field(description="A title for the attribute, to be displayed across the app.")
    description: typing.Optional[str] = pydantic.Field(description="A text description of the attribute.")
    api_slug: str = pydantic.Field(
        description="A unique slug for the attribute for use in API responses and URLs. Formatted in snake case."
    )
    type: AttributeType = pydantic.Field(description="The type of the attribute.")
    is_system_attribute: bool = pydantic.Field(
        description="`true` if this is an Attio system-defined attribute, `false` if defined by a user or non-Attio system."
    )
    is_writable: bool = pydantic.Field(
        description="Whether or not this attribute can be written to. Can only be false when `is_system_attribute` is `true` (user-defined attributes are always writeable). If `false`, this usually means the attribute is enriched by Attio."
    )
    is_required: bool = pydantic.Field(
        description="When `is_required` is `true`, new records/entries must have a value for this attribute. If `false`, values may be `null`. This value does not affect existing data and you do not need to backfill `null` values if changing `is_required` from `false` to `true`."
    )
    is_unique: bool = pydantic.Field(
        description="Whether or not new values for this attribute must be unique. Uniqueness restrictions are only applied to new data and do not apply retroactively to previously created data."
    )
    is_multiselect: bool = pydantic.Field(
        description="Whether or not this attribute can have multiple values. Multiselect is only available on some value types."
    )
    is_default_value_enabled: bool = pydantic.Field(
        description="Whether this attribute has a default value enabled. Must be `true` when `is_required` is `true`."
    )
    is_archived: bool = pydantic.Field(
        description="Whether this attribute has been archived. Archived attributes are hidden from most UI, but can be restored either over the API or in workspace settings. See the [guide on archiving and deleting](/docs/archiving-vs-deleting)for more information."
    )
    default_value: typing.Optional[AttributeDefaultValue] = pydantic.Field(
        description="The default value for this attribute. Static values are used to directly populate values using their contents. Dynamic values are used to lookup data at the point of creation. For example, you could use a dynamic value to insert a value for the currently logged in user. Which default values are available is dependent on the type of the attribute."
    )
    relationship: typing.Optional[AttributeRelationship] = pydantic.Field(
        description="If this attribute is related to another attribute, this is an object that includes an `id` property that identifies the other attribute. `null` means no relationship exists. See [the help center](https://attio.com/help/reference/managing-your-data/attributes#relationship-attributes) for more details about relationship attributes."
    )
    created_at: str = pydantic.Field(description="When this attribute was created.")
    config: AttributeConfig = pydantic.Field(description="Additional, type-dependent configuration for the attribute.")

    def json(self, **kwargs: typing.Any) -> str:
        kwargs_with_defaults: typing.Any = {"by_alias": True, "exclude_unset": True, **kwargs}
        return super().json(**kwargs_with_defaults)

    def dict(self, **kwargs: typing.Any) -> typing.Dict[str, typing.Any]:
        kwargs_with_defaults: typing.Any = {"by_alias": True, "exclude_unset": True, **kwargs}
        return super().dict(**kwargs_with_defaults)

    class Config:
        frozen = True
        
        json_encoders = {dt.datetime: serialize_datetime}
