# This file was auto-generated by Fern from our API Definition.

import typing
import urllib.parse
from json.decoder import JSONDecodeError

from ...core.api_error import ApiError
from ...core.client_wrapper import AsyncClientWrapper, SyncClientWrapper
from ...core.jsonable_encoder import jsonable_encoder
from ...errors.bad_request_error import BadRequestError
from ...errors.forbidden_error import ForbiddenError
from ...errors.not_found_error import NotFoundError
from ...types.forbidden_error_body import ForbiddenErrorBody
from .types.get_v_2_lists_list_response import GetV2ListsListResponse
from .types.get_v_2_lists_response import GetV2ListsResponse
from .types.patch_v_2_lists_list_request_data import PatchV2ListsListRequestData
from .types.patch_v_2_lists_list_response import PatchV2ListsListResponse
from .types.post_v_2_lists_request_data import PostV2ListsRequestData
from .types.post_v_2_lists_response import PostV2ListsResponse

try:
    import pydantic as pydantic  # type: ignore
except ImportError:
    import pydantic  # type: ignore

# this is used as the default value for optional parameters
OMIT = typing.cast(typing.Any, ...)


class ListsClient:
    def __init__(self, *, client_wrapper: SyncClientWrapper):
        self._client_wrapper = client_wrapper

    def list_all_lists(self) -> GetV2ListsResponse:
        """
        List all lists that your access token has access to. lists are returned in the order that they are sorted in the sidebar.

        Required scopes: `list_configuration:read`.

        ---
        from attio.client import attio_api

        client = attio_api(
            token="YOUR_TOKEN",
        )
        client.lists.list_all_lists()
        """
        _response = self._client_wrapper.httpx_client.request(
            "GET",
            urllib.parse.urljoin(f"{self._client_wrapper.get_base_url()}/", "v2/lists"),
            headers=self._client_wrapper.get_headers(),
            timeout=60,
        )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(GetV2ListsResponse, _response.json())  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    def create_a_list(self, *, data: PostV2ListsRequestData) -> PostV2ListsResponse:
        """
        Creates a new list.

        Once you have your list, add attributes to it using the [Create attribute](/reference/post_v2-target-identifier-attributes) API, and add records to it using the [Add records to list](/reference/post_v2-lists-list-entries) API.

        New lists must specify which records can be added with the `parent_object` parameter which accepts either an object slug or an object ID. Permissions for the list are controlled with the `workspace_access` and `workspace_member_access` parameters.

        Please note that new lists must have either `workspace_access` set to `"full-access"` or one or more element of `workspace_member_access` with a `"full-access"` level. It is also possible to receive a `403` billing error if your workspace is not on a plan that supports either advanced workspace or workspace member-level access for lists.

        Required scopes: `list_configuration:read-write`.

        Parameters:
            - data: PostV2ListsRequestData.
        ---
        from attio import (
            PostV2ListsRequestData,
            PostV2ListsRequestDataWorkspaceAccess,
            PostV2ListsRequestDataWorkspaceMemberAccessItem,
            PostV2ListsRequestDataWorkspaceMemberAccessItemLevel,
        )
        from attio.client import attio_api

        client = attio_api(
            token="YOUR_TOKEN",
        )
        client.lists.create_a_list(
            data=PostV2ListsRequestData(
                name="Enterprise Sales",
                api_slug="enterprise_sales",
                parent_object="people",
                workspace_access=PostV2ListsRequestDataWorkspaceAccess.FULL_ACCESS,
                workspace_member_access=[
                    PostV2ListsRequestDataWorkspaceMemberAccessItem(
                        workspace_member_id="50cf242c-7fa3-4cad-87d0-75b1af71c57b",
                        level=PostV2ListsRequestDataWorkspaceMemberAccessItemLevel.FULL_ACCESS,
                    )
                ],
            ),
        )
        """
        _response = self._client_wrapper.httpx_client.request(
            "POST",
            urllib.parse.urljoin(f"{self._client_wrapper.get_base_url()}/", "v2/lists"),
            json=jsonable_encoder({"data": data}),
            headers=self._client_wrapper.get_headers(),
            timeout=60,
        )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(PostV2ListsResponse, _response.json())  # type: ignore
        if _response.status_code == 400:
            raise BadRequestError(pydantic.parse_obj_as(typing.Any, _response.json()))  # type: ignore
        if _response.status_code == 403:
            raise ForbiddenError(pydantic.parse_obj_as(ForbiddenErrorBody, _response.json()))  # type: ignore
        if _response.status_code == 404:
            raise NotFoundError(pydantic.parse_obj_as(typing.Any, _response.json()))  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    def get_a_list(self, list: str) -> GetV2ListsListResponse:
        """
        Gets a single list in your workspace that your access token has access to.

        Required scopes: `list_configuration:read`.

        Parameters:
            - list: str.
        ---
        from attio.client import attio_api

        client = attio_api(
            token="YOUR_TOKEN",
        )
        client.lists.get_a_list(
            list="33ebdbe9-e529-47c9-b894-0ba25e9c15c0",
        )
        """
        _response = self._client_wrapper.httpx_client.request(
            "GET",
            urllib.parse.urljoin(f"{self._client_wrapper.get_base_url()}/", f"v2/lists/{list}"),
            headers=self._client_wrapper.get_headers(),
            timeout=60,
        )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(GetV2ListsListResponse, _response.json())  # type: ignore
        if _response.status_code == 404:
            raise NotFoundError(pydantic.parse_obj_as(typing.Any, _response.json()))  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    def update_a_list(self, list: str, *, data: PatchV2ListsListRequestData) -> PatchV2ListsListResponse:
        """
        Updates an existing list. Permissions for the list are controlled with the `workspace_access` and `workspace_member_access` parameters. Please note that lists must have either `workspace_access` set to `"full-access"` or one or more element of `workspace_member_access` with a `"full-access"` level. It is also possible to receive a `403` billing error if your workspace is not on a plan that supports either advanced workspace or workspace member level access for lists. Changing the parent object of a list is not possible through the API as it can have unintended side-effects that should be considered carefully. If you wish to carry out a parent object change you should do so through the UI.

        Required scopes: `list_configuration:read-write`.

        Parameters:
            - list: str.

            - data: PatchV2ListsListRequestData.
        ---
        from attio import (
            PatchV2ListsListRequestData,
            PatchV2ListsListRequestDataWorkspaceAccess,
            PatchV2ListsListRequestDataWorkspaceMemberAccessItem,
            PatchV2ListsListRequestDataWorkspaceMemberAccessItemLevel,
        )
        from attio.client import attio_api

        client = attio_api(
            token="YOUR_TOKEN",
        )
        client.lists.update_a_list(
            list="33ebdbe9-e529-47c9-b894-0ba25e9c15c0",
            data=PatchV2ListsListRequestData(
                name="Enterprise Sales",
                api_slug="enterprise_sales",
                workspace_access=PatchV2ListsListRequestDataWorkspaceAccess.FULL_ACCESS,
                workspace_member_access=[
                    PatchV2ListsListRequestDataWorkspaceMemberAccessItem(
                        workspace_member_id="50cf242c-7fa3-4cad-87d0-75b1af71c57b",
                        level=PatchV2ListsListRequestDataWorkspaceMemberAccessItemLevel.FULL_ACCESS,
                    )
                ],
            ),
        )
        """
        _response = self._client_wrapper.httpx_client.request(
            "PATCH",
            urllib.parse.urljoin(f"{self._client_wrapper.get_base_url()}/", f"v2/lists/{list}"),
            json=jsonable_encoder({"data": data}),
            headers=self._client_wrapper.get_headers(),
            timeout=60,
        )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(PatchV2ListsListResponse, _response.json())  # type: ignore
        if _response.status_code == 400:
            raise BadRequestError(pydantic.parse_obj_as(typing.Any, _response.json()))  # type: ignore
        if _response.status_code == 404:
            raise NotFoundError(pydantic.parse_obj_as(typing.Any, _response.json()))  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)


class AsyncListsClient:
    def __init__(self, *, client_wrapper: AsyncClientWrapper):
        self._client_wrapper = client_wrapper

    async def list_all_lists(self) -> GetV2ListsResponse:
        """
        List all lists that your access token has access to. lists are returned in the order that they are sorted in the sidebar.

        Required scopes: `list_configuration:read`.

        ---
        from attio.client import Asyncattio_api

        client = Asyncattio_api(
            token="YOUR_TOKEN",
        )
        await client.lists.list_all_lists()
        """
        _response = await self._client_wrapper.httpx_client.request(
            "GET",
            urllib.parse.urljoin(f"{self._client_wrapper.get_base_url()}/", "v2/lists"),
            headers=self._client_wrapper.get_headers(),
            timeout=60,
        )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(GetV2ListsResponse, _response.json())  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    async def create_a_list(self, *, data: PostV2ListsRequestData) -> PostV2ListsResponse:
        """
        Creates a new list.

        Once you have your list, add attributes to it using the [Create attribute](/reference/post_v2-target-identifier-attributes) API, and add records to it using the [Add records to list](/reference/post_v2-lists-list-entries) API.

        New lists must specify which records can be added with the `parent_object` parameter which accepts either an object slug or an object ID. Permissions for the list are controlled with the `workspace_access` and `workspace_member_access` parameters.

        Please note that new lists must have either `workspace_access` set to `"full-access"` or one or more element of `workspace_member_access` with a `"full-access"` level. It is also possible to receive a `403` billing error if your workspace is not on a plan that supports either advanced workspace or workspace member-level access for lists.

        Required scopes: `list_configuration:read-write`.

        Parameters:
            - data: PostV2ListsRequestData.
        ---
        from attio import (
            PostV2ListsRequestData,
            PostV2ListsRequestDataWorkspaceAccess,
            PostV2ListsRequestDataWorkspaceMemberAccessItem,
            PostV2ListsRequestDataWorkspaceMemberAccessItemLevel,
        )
        from attio.client import Asyncattio_api

        client = Asyncattio_api(
            token="YOUR_TOKEN",
        )
        await client.lists.create_a_list(
            data=PostV2ListsRequestData(
                name="Enterprise Sales",
                api_slug="enterprise_sales",
                parent_object="people",
                workspace_access=PostV2ListsRequestDataWorkspaceAccess.FULL_ACCESS,
                workspace_member_access=[
                    PostV2ListsRequestDataWorkspaceMemberAccessItem(
                        workspace_member_id="50cf242c-7fa3-4cad-87d0-75b1af71c57b",
                        level=PostV2ListsRequestDataWorkspaceMemberAccessItemLevel.FULL_ACCESS,
                    )
                ],
            ),
        )
        """
        _response = await self._client_wrapper.httpx_client.request(
            "POST",
            urllib.parse.urljoin(f"{self._client_wrapper.get_base_url()}/", "v2/lists"),
            json=jsonable_encoder({"data": data}),
            headers=self._client_wrapper.get_headers(),
            timeout=60,
        )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(PostV2ListsResponse, _response.json())  # type: ignore
        if _response.status_code == 400:
            raise BadRequestError(pydantic.parse_obj_as(typing.Any, _response.json()))  # type: ignore
        if _response.status_code == 403:
            raise ForbiddenError(pydantic.parse_obj_as(ForbiddenErrorBody, _response.json()))  # type: ignore
        if _response.status_code == 404:
            raise NotFoundError(pydantic.parse_obj_as(typing.Any, _response.json()))  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    async def get_a_list(self, list: str) -> GetV2ListsListResponse:
        """
        Gets a single list in your workspace that your access token has access to.

        Required scopes: `list_configuration:read`.

        Parameters:
            - list: str.
        ---
        from attio.client import Asyncattio_api

        client = Asyncattio_api(
            token="YOUR_TOKEN",
        )
        await client.lists.get_a_list(
            list="33ebdbe9-e529-47c9-b894-0ba25e9c15c0",
        )
        """
        _response = await self._client_wrapper.httpx_client.request(
            "GET",
            urllib.parse.urljoin(f"{self._client_wrapper.get_base_url()}/", f"v2/lists/{list}"),
            headers=self._client_wrapper.get_headers(),
            timeout=60,
        )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(GetV2ListsListResponse, _response.json())  # type: ignore
        if _response.status_code == 404:
            raise NotFoundError(pydantic.parse_obj_as(typing.Any, _response.json()))  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    async def update_a_list(self, list: str, *, data: PatchV2ListsListRequestData) -> PatchV2ListsListResponse:
        """
        Updates an existing list. Permissions for the list are controlled with the `workspace_access` and `workspace_member_access` parameters. Please note that lists must have either `workspace_access` set to `"full-access"` or one or more element of `workspace_member_access` with a `"full-access"` level. It is also possible to receive a `403` billing error if your workspace is not on a plan that supports either advanced workspace or workspace member level access for lists. Changing the parent object of a list is not possible through the API as it can have unintended side-effects that should be considered carefully. If you wish to carry out a parent object change you should do so through the UI.

        Required scopes: `list_configuration:read-write`.

        Parameters:
            - list: str.

            - data: PatchV2ListsListRequestData.
        ---
        from attio import (
            PatchV2ListsListRequestData,
            PatchV2ListsListRequestDataWorkspaceAccess,
            PatchV2ListsListRequestDataWorkspaceMemberAccessItem,
            PatchV2ListsListRequestDataWorkspaceMemberAccessItemLevel,
        )
        from attio.client import Asyncattio_api

        client = Asyncattio_api(
            token="YOUR_TOKEN",
        )
        await client.lists.update_a_list(
            list="33ebdbe9-e529-47c9-b894-0ba25e9c15c0",
            data=PatchV2ListsListRequestData(
                name="Enterprise Sales",
                api_slug="enterprise_sales",
                workspace_access=PatchV2ListsListRequestDataWorkspaceAccess.FULL_ACCESS,
                workspace_member_access=[
                    PatchV2ListsListRequestDataWorkspaceMemberAccessItem(
                        workspace_member_id="50cf242c-7fa3-4cad-87d0-75b1af71c57b",
                        level=PatchV2ListsListRequestDataWorkspaceMemberAccessItemLevel.FULL_ACCESS,
                    )
                ],
            ),
        )
        """
        _response = await self._client_wrapper.httpx_client.request(
            "PATCH",
            urllib.parse.urljoin(f"{self._client_wrapper.get_base_url()}/", f"v2/lists/{list}"),
            json=jsonable_encoder({"data": data}),
            headers=self._client_wrapper.get_headers(),
            timeout=60,
        )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(PatchV2ListsListResponse, _response.json())  # type: ignore
        if _response.status_code == 400:
            raise BadRequestError(pydantic.parse_obj_as(typing.Any, _response.json()))  # type: ignore
        if _response.status_code == 404:
            raise NotFoundError(pydantic.parse_obj_as(typing.Any, _response.json()))  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)
