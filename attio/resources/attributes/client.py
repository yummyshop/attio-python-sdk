# This file was auto-generated by Fern from our API Definition.

import typing
import urllib.parse
from json.decoder import JSONDecodeError

from ...core.api_error import ApiError
from ...core.client_wrapper import AsyncClientWrapper, SyncClientWrapper
from ...core.jsonable_encoder import jsonable_encoder
from ...core.remove_none_from_dict import remove_none_from_dict
from ...errors.bad_request_error import BadRequestError
from ...errors.conflict_error import ConflictError
from ...errors.not_found_error import NotFoundError
from .types.get_v_2_target_identifier_attributes_attribute_options_request_target import (
    GetV2TargetIdentifierAttributesAttributeOptionsRequestTarget,
)
from .types.get_v_2_target_identifier_attributes_attribute_options_response import (
    GetV2TargetIdentifierAttributesAttributeOptionsResponse,
)
from .types.get_v_2_target_identifier_attributes_attribute_request_target import (
    GetV2TargetIdentifierAttributesAttributeRequestTarget,
)
from .types.get_v_2_target_identifier_attributes_attribute_response import (
    GetV2TargetIdentifierAttributesAttributeResponse,
)
from .types.get_v_2_target_identifier_attributes_attribute_statuses_request_target import (
    GetV2TargetIdentifierAttributesAttributeStatusesRequestTarget,
)
from .types.get_v_2_target_identifier_attributes_attribute_statuses_response import (
    GetV2TargetIdentifierAttributesAttributeStatusesResponse,
)
from .types.get_v_2_target_identifier_attributes_request_target import GetV2TargetIdentifierAttributesRequestTarget
from .types.get_v_2_target_identifier_attributes_response import GetV2TargetIdentifierAttributesResponse
from .types.patch_v_2_target_identifier_attributes_attribute_options_option_request_data import (
    PatchV2TargetIdentifierAttributesAttributeOptionsOptionRequestData,
)
from .types.patch_v_2_target_identifier_attributes_attribute_options_option_request_target import (
    PatchV2TargetIdentifierAttributesAttributeOptionsOptionRequestTarget,
)
from .types.patch_v_2_target_identifier_attributes_attribute_options_option_response import (
    PatchV2TargetIdentifierAttributesAttributeOptionsOptionResponse,
)
from .types.patch_v_2_target_identifier_attributes_attribute_request_data import (
    PatchV2TargetIdentifierAttributesAttributeRequestData,
)
from .types.patch_v_2_target_identifier_attributes_attribute_request_target import (
    PatchV2TargetIdentifierAttributesAttributeRequestTarget,
)
from .types.patch_v_2_target_identifier_attributes_attribute_response import (
    PatchV2TargetIdentifierAttributesAttributeResponse,
)
from .types.patch_v_2_target_identifier_attributes_attribute_statuses_status_request_data import (
    PatchV2TargetIdentifierAttributesAttributeStatusesStatusRequestData,
)
from .types.patch_v_2_target_identifier_attributes_attribute_statuses_status_request_target import (
    PatchV2TargetIdentifierAttributesAttributeStatusesStatusRequestTarget,
)
from .types.patch_v_2_target_identifier_attributes_attribute_statuses_status_response import (
    PatchV2TargetIdentifierAttributesAttributeStatusesStatusResponse,
)
from .types.post_v_2_target_identifier_attributes_attribute_options_request_data import (
    PostV2TargetIdentifierAttributesAttributeOptionsRequestData,
)
from .types.post_v_2_target_identifier_attributes_attribute_options_request_target import (
    PostV2TargetIdentifierAttributesAttributeOptionsRequestTarget,
)
from .types.post_v_2_target_identifier_attributes_attribute_options_response import (
    PostV2TargetIdentifierAttributesAttributeOptionsResponse,
)
from .types.post_v_2_target_identifier_attributes_attribute_statuses_request_data import (
    PostV2TargetIdentifierAttributesAttributeStatusesRequestData,
)
from .types.post_v_2_target_identifier_attributes_attribute_statuses_request_target import (
    PostV2TargetIdentifierAttributesAttributeStatusesRequestTarget,
)
from .types.post_v_2_target_identifier_attributes_attribute_statuses_response import (
    PostV2TargetIdentifierAttributesAttributeStatusesResponse,
)
from .types.post_v_2_target_identifier_attributes_request_data import PostV2TargetIdentifierAttributesRequestData
from .types.post_v_2_target_identifier_attributes_request_target import PostV2TargetIdentifierAttributesRequestTarget
from .types.post_v_2_target_identifier_attributes_response import PostV2TargetIdentifierAttributesResponse

try:
    import pydantic as pydantic  # type: ignore
except ImportError:
    import pydantic  # type: ignore

# this is used as the default value for optional parameters
OMIT = typing.cast(typing.Any, ...)


class AttributesClient:
    def __init__(self, *, client_wrapper: SyncClientWrapper):
        self._client_wrapper = client_wrapper

    def list_attributes(
        self,
        target: GetV2TargetIdentifierAttributesRequestTarget,
        identifier: str,
        *,
        limit: typing.Optional[int] = None,
        offset: typing.Optional[int] = None,
        show_archived: typing.Optional[bool] = None,
    ) -> GetV2TargetIdentifierAttributesResponse:
        """
        Lists all attributes defined on a specific object or list. Attributes are returned in the order that they are sorted by in the UI.

        Required scopes: `object_configuration:read`.

        Parameters:
            - target: GetV2TargetIdentifierAttributesRequestTarget.

            - identifier: str.

            - limit: typing.Optional[int].

            - offset: typing.Optional[int].

            - show_archived: typing.Optional[bool].
        ---
        from attio import GetV2TargetIdentifierAttributesRequestTarget
        from attio.client import AttioClient

        client = AttioClient(
            token="YOUR_TOKEN",
        )
        client.attributes.list_attributes(
            target=GetV2TargetIdentifierAttributesRequestTarget.OBJECTS,
            identifier="33ebdbe9-e529-47c9-b894-0ba25e9c15c0",
            limit=1,
            offset=1,
            show_archived=True,
        )
        """
        _response = self._client_wrapper.httpx_client.request(
            "GET",
            urllib.parse.urljoin(f"{self._client_wrapper.get_base_url()}/", f"v2/{target}/{identifier}/attributes"),
            params=remove_none_from_dict({"limit": limit, "offset": offset, "show_archived": show_archived}),
            headers=self._client_wrapper.get_headers(),
            timeout=60,
        )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(GetV2TargetIdentifierAttributesResponse, _response.json())  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    def create_an_attribute(
        self,
        target: PostV2TargetIdentifierAttributesRequestTarget,
        identifier: str,
        *,
        data: PostV2TargetIdentifierAttributesRequestData,
    ) -> PostV2TargetIdentifierAttributesResponse:
        """
        Creates a new attribute on either an object or a list.

        To create an attribute on an object, you must also have the `object_configuration:read-write` scope.

        To create an attribute on a list, you must also have the `list_configuration:read-write` scope.

        Parameters:
            - target: PostV2TargetIdentifierAttributesRequestTarget.

            - identifier: str.

            - data: PostV2TargetIdentifierAttributesRequestData.
        ---
        from attio import (
            PostV2TargetIdentifierAttributesRequestData,
            PostV2TargetIdentifierAttributesRequestDataConfig,
            PostV2TargetIdentifierAttributesRequestDataConfigCurrency,
            PostV2TargetIdentifierAttributesRequestDataConfigCurrencyDefaultCurrencyCode,
            PostV2TargetIdentifierAttributesRequestDataConfigCurrencyDisplayType,
            PostV2TargetIdentifierAttributesRequestDataConfigRecordReference,
            PostV2TargetIdentifierAttributesRequestDataType,
            PostV2TargetIdentifierAttributesRequestTarget,
        )
        from attio.client import AttioClient

        client = AttioClient(
            token="YOUR_TOKEN",
        )
        client.attributes.create_an_attribute(
            target=PostV2TargetIdentifierAttributesRequestTarget.OBJECTS,
            identifier="97052eb9-e65e-443f-a297-f2d9a4a7f795",
            data=PostV2TargetIdentifierAttributesRequestData(
                title="Your Attribute",
                description="Lorem ipsum",
                api_slug="my-attribute",
                type=PostV2TargetIdentifierAttributesRequestDataType.TEXT,
                is_required=True,
                is_unique=True,
                is_multiselect=True,
                config=PostV2TargetIdentifierAttributesRequestDataConfig(
                    currency=PostV2TargetIdentifierAttributesRequestDataConfigCurrency(
                        default_currency_code=PostV2TargetIdentifierAttributesRequestDataConfigCurrencyDefaultCurrencyCode.EUR,
                        display_type=PostV2TargetIdentifierAttributesRequestDataConfigCurrencyDisplayType.CODE,
                    ),
                    record_reference=PostV2TargetIdentifierAttributesRequestDataConfigRecordReference(
                        allowed_objects=["people"],
                    ),
                ),
            ),
        )
        """
        _response = self._client_wrapper.httpx_client.request(
            "POST",
            urllib.parse.urljoin(f"{self._client_wrapper.get_base_url()}/", f"v2/{target}/{identifier}/attributes"),
            json=jsonable_encoder({"data": data}),
            headers=self._client_wrapper.get_headers(),
            timeout=60,
        )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(PostV2TargetIdentifierAttributesResponse, _response.json())  # type: ignore
        if _response.status_code == 400:
            raise BadRequestError(pydantic.parse_obj_as(typing.Any, _response.json()))  # type: ignore
        if _response.status_code == 404:
            raise NotFoundError(pydantic.parse_obj_as(typing.Any, _response.json()))  # type: ignore
        if _response.status_code == 409:
            raise ConflictError(pydantic.parse_obj_as(typing.Any, _response.json()))  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    def get_an_attribute(
        self, target: GetV2TargetIdentifierAttributesAttributeRequestTarget, identifier: str, attribute: str
    ) -> GetV2TargetIdentifierAttributesAttributeResponse:
        """
        Gets information about a single attribute on either an object or a list.

        Required scopes: `object_configuration:read`.

        Parameters:
            - target: GetV2TargetIdentifierAttributesAttributeRequestTarget.

            - identifier: str.

            - attribute: str.
        ---
        from attio import GetV2TargetIdentifierAttributesAttributeRequestTarget
        from attio.client import AttioClient

        client = AttioClient(
            token="YOUR_TOKEN",
        )
        client.attributes.get_an_attribute(
            target=GetV2TargetIdentifierAttributesAttributeRequestTarget.OBJECTS,
            identifier="33ebdbe9-e529-47c9-b894-0ba25e9c15c0",
            attribute="41252299-f8c7-4b5e-99c9-4ff8321d2f96",
        )
        """
        _response = self._client_wrapper.httpx_client.request(
            "GET",
            urllib.parse.urljoin(
                f"{self._client_wrapper.get_base_url()}/", f"v2/{target}/{identifier}/attributes/{attribute}"
            ),
            headers=self._client_wrapper.get_headers(),
            timeout=60,
        )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(GetV2TargetIdentifierAttributesAttributeResponse, _response.json())  # type: ignore
        if _response.status_code == 404:
            raise NotFoundError(pydantic.parse_obj_as(typing.Any, _response.json()))  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    def update_an_attribute(
        self,
        target: PatchV2TargetIdentifierAttributesAttributeRequestTarget,
        identifier: str,
        attribute: str,
        *,
        data: PatchV2TargetIdentifierAttributesAttributeRequestData,
    ) -> PatchV2TargetIdentifierAttributesAttributeResponse:
        """
        Updates a single attribute on a given object or list.

        Required scopes: `object_configuration:read-write`.

        Parameters:
            - target: PatchV2TargetIdentifierAttributesAttributeRequestTarget.

            - identifier: str.

            - attribute: str.

            - data: PatchV2TargetIdentifierAttributesAttributeRequestData.
        ---
        from attio import (
            PatchV2TargetIdentifierAttributesAttributeRequestData,
            PatchV2TargetIdentifierAttributesAttributeRequestDataConfig,
            PatchV2TargetIdentifierAttributesAttributeRequestDataConfigCurrency,
            PatchV2TargetIdentifierAttributesAttributeRequestDataConfigCurrencyDefaultCurrencyCode,
            PatchV2TargetIdentifierAttributesAttributeRequestDataConfigCurrencyDisplayType,
            PatchV2TargetIdentifierAttributesAttributeRequestDataConfigRecordReference,
            PatchV2TargetIdentifierAttributesAttributeRequestTarget,
        )
        from attio.client import AttioClient

        client = AttioClient(
            token="YOUR_TOKEN",
        )
        client.attributes.update_an_attribute(
            target=PatchV2TargetIdentifierAttributesAttributeRequestTarget.OBJECTS,
            identifier="33ebdbe9-e529-47c9-b894-0ba25e9c15c0",
            attribute="41252299-f8c7-4b5e-99c9-4ff8321d2f96",
            data=PatchV2TargetIdentifierAttributesAttributeRequestData(
                title="Your Attribute",
                description="Lorem ipsum",
                api_slug="my-attribute",
                is_required=True,
                config=PatchV2TargetIdentifierAttributesAttributeRequestDataConfig(
                    currency=PatchV2TargetIdentifierAttributesAttributeRequestDataConfigCurrency(
                        default_currency_code=PatchV2TargetIdentifierAttributesAttributeRequestDataConfigCurrencyDefaultCurrencyCode.EUR,
                        display_type=PatchV2TargetIdentifierAttributesAttributeRequestDataConfigCurrencyDisplayType.CODE,
                    ),
                    record_reference=PatchV2TargetIdentifierAttributesAttributeRequestDataConfigRecordReference(
                        allowed_objects=["people"],
                    ),
                ),
                is_archived=False,
            ),
        )
        """
        _response = self._client_wrapper.httpx_client.request(
            "PATCH",
            urllib.parse.urljoin(
                f"{self._client_wrapper.get_base_url()}/", f"v2/{target}/{identifier}/attributes/{attribute}"
            ),
            json=jsonable_encoder({"data": data}),
            headers=self._client_wrapper.get_headers(),
            timeout=60,
        )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(PatchV2TargetIdentifierAttributesAttributeResponse, _response.json())  # type: ignore
        if _response.status_code == 400:
            raise BadRequestError(pydantic.parse_obj_as(typing.Any, _response.json()))  # type: ignore
        if _response.status_code == 404:
            raise NotFoundError(pydantic.parse_obj_as(typing.Any, _response.json()))  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    def list_select_options(
        self,
        target: GetV2TargetIdentifierAttributesAttributeOptionsRequestTarget,
        identifier: str,
        attribute: str,
        *,
        show_archived: typing.Optional[bool] = None,
    ) -> GetV2TargetIdentifierAttributesAttributeOptionsResponse:
        """
        Lists all select options for a particular attribute on either an object or a list.

        Required scopes: `object_configuration:read`.

        Parameters:
            - target: GetV2TargetIdentifierAttributesAttributeOptionsRequestTarget.

            - identifier: str.

            - attribute: str.

            - show_archived: typing.Optional[bool].
        ---
        from attio import GetV2TargetIdentifierAttributesAttributeOptionsRequestTarget
        from attio.client import AttioClient

        client = AttioClient(
            token="YOUR_TOKEN",
        )
        client.attributes.list_select_options(
            target=GetV2TargetIdentifierAttributesAttributeOptionsRequestTarget.OBJECTS,
            identifier="33ebdbe9-e529-47c9-b894-0ba25e9c15c0",
            attribute="41252299-f8c7-4b5e-99c9-4ff8321d2f96",
            show_archived=True,
        )
        """
        _response = self._client_wrapper.httpx_client.request(
            "GET",
            urllib.parse.urljoin(
                f"{self._client_wrapper.get_base_url()}/", f"v2/{target}/{identifier}/attributes/{attribute}/options"
            ),
            params=remove_none_from_dict({"show_archived": show_archived}),
            headers=self._client_wrapper.get_headers(),
            timeout=60,
        )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(GetV2TargetIdentifierAttributesAttributeOptionsResponse, _response.json())  # type: ignore
        if _response.status_code == 404:
            raise NotFoundError(pydantic.parse_obj_as(typing.Any, _response.json()))  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    def create_a_select_option(
        self,
        target: PostV2TargetIdentifierAttributesAttributeOptionsRequestTarget,
        identifier: str,
        attribute: str,
        *,
        data: PostV2TargetIdentifierAttributesAttributeOptionsRequestData,
    ) -> PostV2TargetIdentifierAttributesAttributeOptionsResponse:
        """
        Adds a select option to a select attribute on an object or a list.

        Required scopes: `object_configuration:read-write`.

        Parameters:
            - target: PostV2TargetIdentifierAttributesAttributeOptionsRequestTarget.

            - identifier: str.

            - attribute: str.

            - data: PostV2TargetIdentifierAttributesAttributeOptionsRequestData.
        ---
        from attio import (
            PostV2TargetIdentifierAttributesAttributeOptionsRequestData,
            PostV2TargetIdentifierAttributesAttributeOptionsRequestTarget,
        )
        from attio.client import AttioClient

        client = AttioClient(
            token="YOUR_TOKEN",
        )
        client.attributes.create_a_select_option(
            target=PostV2TargetIdentifierAttributesAttributeOptionsRequestTarget.OBJECTS,
            identifier="33ebdbe9-e529-47c9-b894-0ba25e9c15c0",
            attribute="41252299-f8c7-4b5e-99c9-4ff8321d2f96",
            data=PostV2TargetIdentifierAttributesAttributeOptionsRequestData(
                title="Medium",
            ),
        )
        """
        _response = self._client_wrapper.httpx_client.request(
            "POST",
            urllib.parse.urljoin(
                f"{self._client_wrapper.get_base_url()}/", f"v2/{target}/{identifier}/attributes/{attribute}/options"
            ),
            json=jsonable_encoder({"data": data}),
            headers=self._client_wrapper.get_headers(),
            timeout=60,
        )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(PostV2TargetIdentifierAttributesAttributeOptionsResponse, _response.json())  # type: ignore
        if _response.status_code == 400:
            raise BadRequestError(pydantic.parse_obj_as(typing.Any, _response.json()))  # type: ignore
        if _response.status_code == 404:
            raise NotFoundError(pydantic.parse_obj_as(typing.Any, _response.json()))  # type: ignore
        if _response.status_code == 409:
            raise ConflictError(pydantic.parse_obj_as(typing.Any, _response.json()))  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    def update_a_select_option(
        self,
        target: PatchV2TargetIdentifierAttributesAttributeOptionsOptionRequestTarget,
        identifier: str,
        attribute: str,
        option: str,
        *,
        data: PatchV2TargetIdentifierAttributesAttributeOptionsOptionRequestData,
    ) -> PatchV2TargetIdentifierAttributesAttributeOptionsOptionResponse:
        """
        Updates a select option on an attribute on either an object or a list.

        Required scopes: `object_configuration:read-write`.

        Parameters:
            - target: PatchV2TargetIdentifierAttributesAttributeOptionsOptionRequestTarget.

            - identifier: str.

            - attribute: str.

            - option: str.

            - data: PatchV2TargetIdentifierAttributesAttributeOptionsOptionRequestData.
        ---
        from attio import (
            PatchV2TargetIdentifierAttributesAttributeOptionsOptionRequestData,
            PatchV2TargetIdentifierAttributesAttributeOptionsOptionRequestTarget,
        )
        from attio.client import AttioClient

        client = AttioClient(
            token="YOUR_TOKEN",
        )
        client.attributes.update_a_select_option(
            target=PatchV2TargetIdentifierAttributesAttributeOptionsOptionRequestTarget.OBJECTS,
            identifier="33ebdbe9-e529-47c9-b894-0ba25e9c15c0",
            attribute="41252299-f8c7-4b5e-99c9-4ff8321d2f96",
            option="Medium",
            data=PatchV2TargetIdentifierAttributesAttributeOptionsOptionRequestData(
                title="Medium",
                is_archived=False,
            ),
        )
        """
        _response = self._client_wrapper.httpx_client.request(
            "PATCH",
            urllib.parse.urljoin(
                f"{self._client_wrapper.get_base_url()}/",
                f"v2/{target}/{identifier}/attributes/{attribute}/options/{option}",
            ),
            json=jsonable_encoder({"data": data}),
            headers=self._client_wrapper.get_headers(),
            timeout=60,
        )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(PatchV2TargetIdentifierAttributesAttributeOptionsOptionResponse, _response.json())  # type: ignore
        if _response.status_code == 400:
            raise BadRequestError(pydantic.parse_obj_as(typing.Any, _response.json()))  # type: ignore
        if _response.status_code == 404:
            raise NotFoundError(pydantic.parse_obj_as(typing.Any, _response.json()))  # type: ignore
        if _response.status_code == 409:
            raise ConflictError(pydantic.parse_obj_as(typing.Any, _response.json()))  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    def list_statuses(
        self,
        target: GetV2TargetIdentifierAttributesAttributeStatusesRequestTarget,
        identifier: str,
        attribute: str,
        *,
        show_archived: typing.Optional[bool] = None,
    ) -> GetV2TargetIdentifierAttributesAttributeStatusesResponse:
        """
        Lists all statuses for a particular status attribute on either an object or a list.

        Required scopes: `object_configuration:read`.

        Parameters:
            - target: GetV2TargetIdentifierAttributesAttributeStatusesRequestTarget.

            - identifier: str.

            - attribute: str.

            - show_archived: typing.Optional[bool].
        ---
        from attio import GetV2TargetIdentifierAttributesAttributeStatusesRequestTarget
        from attio.client import AttioClient

        client = AttioClient(
            token="YOUR_TOKEN",
        )
        client.attributes.list_statuses(
            target=GetV2TargetIdentifierAttributesAttributeStatusesRequestTarget.LISTS,
            identifier="33ebdbe9-e529-47c9-b894-0ba25e9c15c0",
            attribute="41252299-f8c7-4b5e-99c9-4ff8321d2f96",
            show_archived=True,
        )
        """
        _response = self._client_wrapper.httpx_client.request(
            "GET",
            urllib.parse.urljoin(
                f"{self._client_wrapper.get_base_url()}/", f"v2/{target}/{identifier}/attributes/{attribute}/statuses"
            ),
            params=remove_none_from_dict({"show_archived": show_archived}),
            headers=self._client_wrapper.get_headers(),
            timeout=60,
        )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(GetV2TargetIdentifierAttributesAttributeStatusesResponse, _response.json())  # type: ignore
        if _response.status_code == 404:
            raise NotFoundError(pydantic.parse_obj_as(typing.Any, _response.json()))  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    def create_a_status(
        self,
        target: PostV2TargetIdentifierAttributesAttributeStatusesRequestTarget,
        identifier: str,
        attribute: str,
        *,
        data: PostV2TargetIdentifierAttributesAttributeStatusesRequestData,
    ) -> PostV2TargetIdentifierAttributesAttributeStatusesResponse:
        """
        Add a new status to a status attribute on either an object or a list.

        Required scopes: `object_configuration:read-write`.

        Parameters:
            - target: PostV2TargetIdentifierAttributesAttributeStatusesRequestTarget.

            - identifier: str.

            - attribute: str.

            - data: PostV2TargetIdentifierAttributesAttributeStatusesRequestData.
        ---
        from attio import (
            PostV2TargetIdentifierAttributesAttributeStatusesRequestData,
            PostV2TargetIdentifierAttributesAttributeStatusesRequestTarget,
        )
        from attio.client import AttioClient

        client = AttioClient(
            token="YOUR_TOKEN",
        )
        client.attributes.create_a_status(
            target=PostV2TargetIdentifierAttributesAttributeStatusesRequestTarget.LISTS,
            identifier="33ebdbe9-e529-47c9-b894-0ba25e9c15c0",
            attribute="41252299-f8c7-4b5e-99c9-4ff8321d2f96",
            data=PostV2TargetIdentifierAttributesAttributeStatusesRequestData(
                title="In Progress",
                celebration_enabled=True,
                target_time_in_status="P0Y0M1DT0H0M0S",
            ),
        )
        """
        _response = self._client_wrapper.httpx_client.request(
            "POST",
            urllib.parse.urljoin(
                f"{self._client_wrapper.get_base_url()}/", f"v2/{target}/{identifier}/attributes/{attribute}/statuses"
            ),
            json=jsonable_encoder({"data": data}),
            headers=self._client_wrapper.get_headers(),
            timeout=60,
        )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(PostV2TargetIdentifierAttributesAttributeStatusesResponse, _response.json())  # type: ignore
        if _response.status_code == 400:
            raise BadRequestError(pydantic.parse_obj_as(typing.Any, _response.json()))  # type: ignore
        if _response.status_code == 404:
            raise NotFoundError(pydantic.parse_obj_as(typing.Any, _response.json()))  # type: ignore
        if _response.status_code == 409:
            raise ConflictError(pydantic.parse_obj_as(typing.Any, _response.json()))  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    def update_a_status(
        self,
        target: PatchV2TargetIdentifierAttributesAttributeStatusesStatusRequestTarget,
        identifier: str,
        attribute: str,
        status: str,
        *,
        data: PatchV2TargetIdentifierAttributesAttributeStatusesStatusRequestData,
    ) -> PatchV2TargetIdentifierAttributesAttributeStatusesStatusResponse:
        """
        Update a status on an status attribute on either an object or a list.

        Required scopes: `object_configuration:read-write`.

        Parameters:
            - target: PatchV2TargetIdentifierAttributesAttributeStatusesStatusRequestTarget.

            - identifier: str.

            - attribute: str.

            - status: str.

            - data: PatchV2TargetIdentifierAttributesAttributeStatusesStatusRequestData.
        ---
        from attio import (
            PatchV2TargetIdentifierAttributesAttributeStatusesStatusRequestData,
            PatchV2TargetIdentifierAttributesAttributeStatusesStatusRequestTarget,
        )
        from attio.client import AttioClient

        client = AttioClient(
            token="YOUR_TOKEN",
        )
        client.attributes.update_a_status(
            target=PatchV2TargetIdentifierAttributesAttributeStatusesStatusRequestTarget.LISTS,
            identifier="33ebdbe9-e529-47c9-b894-0ba25e9c15c0",
            attribute="41252299-f8c7-4b5e-99c9-4ff8321d2f96",
            status="In Progress",
            data=PatchV2TargetIdentifierAttributesAttributeStatusesStatusRequestData(
                title="In Progress",
                celebration_enabled=True,
                target_time_in_status="P0Y0M1DT0H0M0S",
                is_archived=False,
            ),
        )
        """
        _response = self._client_wrapper.httpx_client.request(
            "PATCH",
            urllib.parse.urljoin(
                f"{self._client_wrapper.get_base_url()}/",
                f"v2/{target}/{identifier}/attributes/{attribute}/statuses/{status}",
            ),
            json=jsonable_encoder({"data": data}),
            headers=self._client_wrapper.get_headers(),
            timeout=60,
        )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(PatchV2TargetIdentifierAttributesAttributeStatusesStatusResponse, _response.json())  # type: ignore
        if _response.status_code == 400:
            raise BadRequestError(pydantic.parse_obj_as(typing.Any, _response.json()))  # type: ignore
        if _response.status_code == 404:
            raise NotFoundError(pydantic.parse_obj_as(typing.Any, _response.json()))  # type: ignore
        if _response.status_code == 409:
            raise ConflictError(pydantic.parse_obj_as(typing.Any, _response.json()))  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)


class AsyncAttributesClient:
    def __init__(self, *, client_wrapper: AsyncClientWrapper):
        self._client_wrapper = client_wrapper

    async def list_attributes(
        self,
        target: GetV2TargetIdentifierAttributesRequestTarget,
        identifier: str,
        *,
        limit: typing.Optional[int] = None,
        offset: typing.Optional[int] = None,
        show_archived: typing.Optional[bool] = None,
    ) -> GetV2TargetIdentifierAttributesResponse:
        """
        Lists all attributes defined on a specific object or list. Attributes are returned in the order that they are sorted by in the UI.

        Required scopes: `object_configuration:read`.

        Parameters:
            - target: GetV2TargetIdentifierAttributesRequestTarget.

            - identifier: str.

            - limit: typing.Optional[int].

            - offset: typing.Optional[int].

            - show_archived: typing.Optional[bool].
        ---
        from attio import GetV2TargetIdentifierAttributesRequestTarget
        from attio.client import AsyncAttioClient

        client = AsyncAttioClient(
            token="YOUR_TOKEN",
        )
        await client.attributes.list_attributes(
            target=GetV2TargetIdentifierAttributesRequestTarget.OBJECTS,
            identifier="33ebdbe9-e529-47c9-b894-0ba25e9c15c0",
            limit=1,
            offset=1,
            show_archived=True,
        )
        """
        _response = await self._client_wrapper.httpx_client.request(
            "GET",
            urllib.parse.urljoin(f"{self._client_wrapper.get_base_url()}/", f"v2/{target}/{identifier}/attributes"),
            params=remove_none_from_dict({"limit": limit, "offset": offset, "show_archived": show_archived}),
            headers=self._client_wrapper.get_headers(),
            timeout=60,
        )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(GetV2TargetIdentifierAttributesResponse, _response.json())  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    async def create_an_attribute(
        self,
        target: PostV2TargetIdentifierAttributesRequestTarget,
        identifier: str,
        *,
        data: PostV2TargetIdentifierAttributesRequestData,
    ) -> PostV2TargetIdentifierAttributesResponse:
        """
        Creates a new attribute on either an object or a list.

        To create an attribute on an object, you must also have the `object_configuration:read-write` scope.

        To create an attribute on a list, you must also have the `list_configuration:read-write` scope.

        Parameters:
            - target: PostV2TargetIdentifierAttributesRequestTarget.

            - identifier: str.

            - data: PostV2TargetIdentifierAttributesRequestData.
        ---
        from attio import (
            PostV2TargetIdentifierAttributesRequestData,
            PostV2TargetIdentifierAttributesRequestDataConfig,
            PostV2TargetIdentifierAttributesRequestDataConfigCurrency,
            PostV2TargetIdentifierAttributesRequestDataConfigCurrencyDefaultCurrencyCode,
            PostV2TargetIdentifierAttributesRequestDataConfigCurrencyDisplayType,
            PostV2TargetIdentifierAttributesRequestDataConfigRecordReference,
            PostV2TargetIdentifierAttributesRequestDataType,
            PostV2TargetIdentifierAttributesRequestTarget,
        )
        from attio.client import AsyncAttioClient

        client = AsyncAttioClient(
            token="YOUR_TOKEN",
        )
        await client.attributes.create_an_attribute(
            target=PostV2TargetIdentifierAttributesRequestTarget.OBJECTS,
            identifier="97052eb9-e65e-443f-a297-f2d9a4a7f795",
            data=PostV2TargetIdentifierAttributesRequestData(
                title="Your Attribute",
                description="Lorem ipsum",
                api_slug="my-attribute",
                type=PostV2TargetIdentifierAttributesRequestDataType.TEXT,
                is_required=True,
                is_unique=True,
                is_multiselect=True,
                config=PostV2TargetIdentifierAttributesRequestDataConfig(
                    currency=PostV2TargetIdentifierAttributesRequestDataConfigCurrency(
                        default_currency_code=PostV2TargetIdentifierAttributesRequestDataConfigCurrencyDefaultCurrencyCode.EUR,
                        display_type=PostV2TargetIdentifierAttributesRequestDataConfigCurrencyDisplayType.CODE,
                    ),
                    record_reference=PostV2TargetIdentifierAttributesRequestDataConfigRecordReference(
                        allowed_objects=["people"],
                    ),
                ),
            ),
        )
        """
        _response = await self._client_wrapper.httpx_client.request(
            "POST",
            urllib.parse.urljoin(f"{self._client_wrapper.get_base_url()}/", f"v2/{target}/{identifier}/attributes"),
            json=jsonable_encoder({"data": data}),
            headers=self._client_wrapper.get_headers(),
            timeout=60,
        )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(PostV2TargetIdentifierAttributesResponse, _response.json())  # type: ignore
        if _response.status_code == 400:
            raise BadRequestError(pydantic.parse_obj_as(typing.Any, _response.json()))  # type: ignore
        if _response.status_code == 404:
            raise NotFoundError(pydantic.parse_obj_as(typing.Any, _response.json()))  # type: ignore
        if _response.status_code == 409:
            raise ConflictError(pydantic.parse_obj_as(typing.Any, _response.json()))  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    async def get_an_attribute(
        self, target: GetV2TargetIdentifierAttributesAttributeRequestTarget, identifier: str, attribute: str
    ) -> GetV2TargetIdentifierAttributesAttributeResponse:
        """
        Gets information about a single attribute on either an object or a list.

        Required scopes: `object_configuration:read`.

        Parameters:
            - target: GetV2TargetIdentifierAttributesAttributeRequestTarget.

            - identifier: str.

            - attribute: str.
        ---
        from attio import GetV2TargetIdentifierAttributesAttributeRequestTarget
        from attio.client import AsyncAttioClient

        client = AsyncAttioClient(
            token="YOUR_TOKEN",
        )
        await client.attributes.get_an_attribute(
            target=GetV2TargetIdentifierAttributesAttributeRequestTarget.OBJECTS,
            identifier="33ebdbe9-e529-47c9-b894-0ba25e9c15c0",
            attribute="41252299-f8c7-4b5e-99c9-4ff8321d2f96",
        )
        """
        _response = await self._client_wrapper.httpx_client.request(
            "GET",
            urllib.parse.urljoin(
                f"{self._client_wrapper.get_base_url()}/", f"v2/{target}/{identifier}/attributes/{attribute}"
            ),
            headers=self._client_wrapper.get_headers(),
            timeout=60,
        )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(GetV2TargetIdentifierAttributesAttributeResponse, _response.json())  # type: ignore
        if _response.status_code == 404:
            raise NotFoundError(pydantic.parse_obj_as(typing.Any, _response.json()))  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    async def update_an_attribute(
        self,
        target: PatchV2TargetIdentifierAttributesAttributeRequestTarget,
        identifier: str,
        attribute: str,
        *,
        data: PatchV2TargetIdentifierAttributesAttributeRequestData,
    ) -> PatchV2TargetIdentifierAttributesAttributeResponse:
        """
        Updates a single attribute on a given object or list.

        Required scopes: `object_configuration:read-write`.

        Parameters:
            - target: PatchV2TargetIdentifierAttributesAttributeRequestTarget.

            - identifier: str.

            - attribute: str.

            - data: PatchV2TargetIdentifierAttributesAttributeRequestData.
        ---
        from attio import (
            PatchV2TargetIdentifierAttributesAttributeRequestData,
            PatchV2TargetIdentifierAttributesAttributeRequestDataConfig,
            PatchV2TargetIdentifierAttributesAttributeRequestDataConfigCurrency,
            PatchV2TargetIdentifierAttributesAttributeRequestDataConfigCurrencyDefaultCurrencyCode,
            PatchV2TargetIdentifierAttributesAttributeRequestDataConfigCurrencyDisplayType,
            PatchV2TargetIdentifierAttributesAttributeRequestDataConfigRecordReference,
            PatchV2TargetIdentifierAttributesAttributeRequestTarget,
        )
        from attio.client import AsyncAttioClient

        client = AsyncAttioClient(
            token="YOUR_TOKEN",
        )
        await client.attributes.update_an_attribute(
            target=PatchV2TargetIdentifierAttributesAttributeRequestTarget.OBJECTS,
            identifier="33ebdbe9-e529-47c9-b894-0ba25e9c15c0",
            attribute="41252299-f8c7-4b5e-99c9-4ff8321d2f96",
            data=PatchV2TargetIdentifierAttributesAttributeRequestData(
                title="Your Attribute",
                description="Lorem ipsum",
                api_slug="my-attribute",
                is_required=True,
                config=PatchV2TargetIdentifierAttributesAttributeRequestDataConfig(
                    currency=PatchV2TargetIdentifierAttributesAttributeRequestDataConfigCurrency(
                        default_currency_code=PatchV2TargetIdentifierAttributesAttributeRequestDataConfigCurrencyDefaultCurrencyCode.EUR,
                        display_type=PatchV2TargetIdentifierAttributesAttributeRequestDataConfigCurrencyDisplayType.CODE,
                    ),
                    record_reference=PatchV2TargetIdentifierAttributesAttributeRequestDataConfigRecordReference(
                        allowed_objects=["people"],
                    ),
                ),
                is_archived=False,
            ),
        )
        """
        _response = await self._client_wrapper.httpx_client.request(
            "PATCH",
            urllib.parse.urljoin(
                f"{self._client_wrapper.get_base_url()}/", f"v2/{target}/{identifier}/attributes/{attribute}"
            ),
            json=jsonable_encoder({"data": data}),
            headers=self._client_wrapper.get_headers(),
            timeout=60,
        )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(PatchV2TargetIdentifierAttributesAttributeResponse, _response.json())  # type: ignore
        if _response.status_code == 400:
            raise BadRequestError(pydantic.parse_obj_as(typing.Any, _response.json()))  # type: ignore
        if _response.status_code == 404:
            raise NotFoundError(pydantic.parse_obj_as(typing.Any, _response.json()))  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    async def list_select_options(
        self,
        target: GetV2TargetIdentifierAttributesAttributeOptionsRequestTarget,
        identifier: str,
        attribute: str,
        *,
        show_archived: typing.Optional[bool] = None,
    ) -> GetV2TargetIdentifierAttributesAttributeOptionsResponse:
        """
        Lists all select options for a particular attribute on either an object or a list.

        Required scopes: `object_configuration:read`.

        Parameters:
            - target: GetV2TargetIdentifierAttributesAttributeOptionsRequestTarget.

            - identifier: str.

            - attribute: str.

            - show_archived: typing.Optional[bool].
        ---
        from attio import GetV2TargetIdentifierAttributesAttributeOptionsRequestTarget
        from attio.client import AsyncAttioClient

        client = AsyncAttioClient(
            token="YOUR_TOKEN",
        )
        await client.attributes.list_select_options(
            target=GetV2TargetIdentifierAttributesAttributeOptionsRequestTarget.OBJECTS,
            identifier="33ebdbe9-e529-47c9-b894-0ba25e9c15c0",
            attribute="41252299-f8c7-4b5e-99c9-4ff8321d2f96",
            show_archived=True,
        )
        """
        _response = await self._client_wrapper.httpx_client.request(
            "GET",
            urllib.parse.urljoin(
                f"{self._client_wrapper.get_base_url()}/", f"v2/{target}/{identifier}/attributes/{attribute}/options"
            ),
            params=remove_none_from_dict({"show_archived": show_archived}),
            headers=self._client_wrapper.get_headers(),
            timeout=60,
        )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(GetV2TargetIdentifierAttributesAttributeOptionsResponse, _response.json())  # type: ignore
        if _response.status_code == 404:
            raise NotFoundError(pydantic.parse_obj_as(typing.Any, _response.json()))  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    async def create_a_select_option(
        self,
        target: PostV2TargetIdentifierAttributesAttributeOptionsRequestTarget,
        identifier: str,
        attribute: str,
        *,
        data: PostV2TargetIdentifierAttributesAttributeOptionsRequestData,
    ) -> PostV2TargetIdentifierAttributesAttributeOptionsResponse:
        """
        Adds a select option to a select attribute on an object or a list.

        Required scopes: `object_configuration:read-write`.

        Parameters:
            - target: PostV2TargetIdentifierAttributesAttributeOptionsRequestTarget.

            - identifier: str.

            - attribute: str.

            - data: PostV2TargetIdentifierAttributesAttributeOptionsRequestData.
        ---
        from attio import (
            PostV2TargetIdentifierAttributesAttributeOptionsRequestData,
            PostV2TargetIdentifierAttributesAttributeOptionsRequestTarget,
        )
        from attio.client import AsyncAttioClient

        client = AsyncAttioClient(
            token="YOUR_TOKEN",
        )
        await client.attributes.create_a_select_option(
            target=PostV2TargetIdentifierAttributesAttributeOptionsRequestTarget.OBJECTS,
            identifier="33ebdbe9-e529-47c9-b894-0ba25e9c15c0",
            attribute="41252299-f8c7-4b5e-99c9-4ff8321d2f96",
            data=PostV2TargetIdentifierAttributesAttributeOptionsRequestData(
                title="Medium",
            ),
        )
        """
        _response = await self._client_wrapper.httpx_client.request(
            "POST",
            urllib.parse.urljoin(
                f"{self._client_wrapper.get_base_url()}/", f"v2/{target}/{identifier}/attributes/{attribute}/options"
            ),
            json=jsonable_encoder({"data": data}),
            headers=self._client_wrapper.get_headers(),
            timeout=60,
        )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(PostV2TargetIdentifierAttributesAttributeOptionsResponse, _response.json())  # type: ignore
        if _response.status_code == 400:
            raise BadRequestError(pydantic.parse_obj_as(typing.Any, _response.json()))  # type: ignore
        if _response.status_code == 404:
            raise NotFoundError(pydantic.parse_obj_as(typing.Any, _response.json()))  # type: ignore
        if _response.status_code == 409:
            raise ConflictError(pydantic.parse_obj_as(typing.Any, _response.json()))  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    async def update_a_select_option(
        self,
        target: PatchV2TargetIdentifierAttributesAttributeOptionsOptionRequestTarget,
        identifier: str,
        attribute: str,
        option: str,
        *,
        data: PatchV2TargetIdentifierAttributesAttributeOptionsOptionRequestData,
    ) -> PatchV2TargetIdentifierAttributesAttributeOptionsOptionResponse:
        """
        Updates a select option on an attribute on either an object or a list.

        Required scopes: `object_configuration:read-write`.

        Parameters:
            - target: PatchV2TargetIdentifierAttributesAttributeOptionsOptionRequestTarget.

            - identifier: str.

            - attribute: str.

            - option: str.

            - data: PatchV2TargetIdentifierAttributesAttributeOptionsOptionRequestData.
        ---
        from attio import (
            PatchV2TargetIdentifierAttributesAttributeOptionsOptionRequestData,
            PatchV2TargetIdentifierAttributesAttributeOptionsOptionRequestTarget,
        )
        from attio.client import AsyncAttioClient

        client = AsyncAttioClient(
            token="YOUR_TOKEN",
        )
        await client.attributes.update_a_select_option(
            target=PatchV2TargetIdentifierAttributesAttributeOptionsOptionRequestTarget.OBJECTS,
            identifier="33ebdbe9-e529-47c9-b894-0ba25e9c15c0",
            attribute="41252299-f8c7-4b5e-99c9-4ff8321d2f96",
            option="Medium",
            data=PatchV2TargetIdentifierAttributesAttributeOptionsOptionRequestData(
                title="Medium",
                is_archived=False,
            ),
        )
        """
        _response = await self._client_wrapper.httpx_client.request(
            "PATCH",
            urllib.parse.urljoin(
                f"{self._client_wrapper.get_base_url()}/",
                f"v2/{target}/{identifier}/attributes/{attribute}/options/{option}",
            ),
            json=jsonable_encoder({"data": data}),
            headers=self._client_wrapper.get_headers(),
            timeout=60,
        )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(PatchV2TargetIdentifierAttributesAttributeOptionsOptionResponse, _response.json())  # type: ignore
        if _response.status_code == 400:
            raise BadRequestError(pydantic.parse_obj_as(typing.Any, _response.json()))  # type: ignore
        if _response.status_code == 404:
            raise NotFoundError(pydantic.parse_obj_as(typing.Any, _response.json()))  # type: ignore
        if _response.status_code == 409:
            raise ConflictError(pydantic.parse_obj_as(typing.Any, _response.json()))  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    async def list_statuses(
        self,
        target: GetV2TargetIdentifierAttributesAttributeStatusesRequestTarget,
        identifier: str,
        attribute: str,
        *,
        show_archived: typing.Optional[bool] = None,
    ) -> GetV2TargetIdentifierAttributesAttributeStatusesResponse:
        """
        Lists all statuses for a particular status attribute on either an object or a list.

        Required scopes: `object_configuration:read`.

        Parameters:
            - target: GetV2TargetIdentifierAttributesAttributeStatusesRequestTarget.

            - identifier: str.

            - attribute: str.

            - show_archived: typing.Optional[bool].
        ---
        from attio import GetV2TargetIdentifierAttributesAttributeStatusesRequestTarget
        from attio.client import AsyncAttioClient

        client = AsyncAttioClient(
            token="YOUR_TOKEN",
        )
        await client.attributes.list_statuses(
            target=GetV2TargetIdentifierAttributesAttributeStatusesRequestTarget.LISTS,
            identifier="33ebdbe9-e529-47c9-b894-0ba25e9c15c0",
            attribute="41252299-f8c7-4b5e-99c9-4ff8321d2f96",
            show_archived=True,
        )
        """
        _response = await self._client_wrapper.httpx_client.request(
            "GET",
            urllib.parse.urljoin(
                f"{self._client_wrapper.get_base_url()}/", f"v2/{target}/{identifier}/attributes/{attribute}/statuses"
            ),
            params=remove_none_from_dict({"show_archived": show_archived}),
            headers=self._client_wrapper.get_headers(),
            timeout=60,
        )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(GetV2TargetIdentifierAttributesAttributeStatusesResponse, _response.json())  # type: ignore
        if _response.status_code == 404:
            raise NotFoundError(pydantic.parse_obj_as(typing.Any, _response.json()))  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    async def create_a_status(
        self,
        target: PostV2TargetIdentifierAttributesAttributeStatusesRequestTarget,
        identifier: str,
        attribute: str,
        *,
        data: PostV2TargetIdentifierAttributesAttributeStatusesRequestData,
    ) -> PostV2TargetIdentifierAttributesAttributeStatusesResponse:
        """
        Add a new status to a status attribute on either an object or a list.

        Required scopes: `object_configuration:read-write`.

        Parameters:
            - target: PostV2TargetIdentifierAttributesAttributeStatusesRequestTarget.

            - identifier: str.

            - attribute: str.

            - data: PostV2TargetIdentifierAttributesAttributeStatusesRequestData.
        ---
        from attio import (
            PostV2TargetIdentifierAttributesAttributeStatusesRequestData,
            PostV2TargetIdentifierAttributesAttributeStatusesRequestTarget,
        )
        from attio.client import AsyncAttioClient

        client = AsyncAttioClient(
            token="YOUR_TOKEN",
        )
        await client.attributes.create_a_status(
            target=PostV2TargetIdentifierAttributesAttributeStatusesRequestTarget.LISTS,
            identifier="33ebdbe9-e529-47c9-b894-0ba25e9c15c0",
            attribute="41252299-f8c7-4b5e-99c9-4ff8321d2f96",
            data=PostV2TargetIdentifierAttributesAttributeStatusesRequestData(
                title="In Progress",
                celebration_enabled=True,
                target_time_in_status="P0Y0M1DT0H0M0S",
            ),
        )
        """
        _response = await self._client_wrapper.httpx_client.request(
            "POST",
            urllib.parse.urljoin(
                f"{self._client_wrapper.get_base_url()}/", f"v2/{target}/{identifier}/attributes/{attribute}/statuses"
            ),
            json=jsonable_encoder({"data": data}),
            headers=self._client_wrapper.get_headers(),
            timeout=60,
        )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(PostV2TargetIdentifierAttributesAttributeStatusesResponse, _response.json())  # type: ignore
        if _response.status_code == 400:
            raise BadRequestError(pydantic.parse_obj_as(typing.Any, _response.json()))  # type: ignore
        if _response.status_code == 404:
            raise NotFoundError(pydantic.parse_obj_as(typing.Any, _response.json()))  # type: ignore
        if _response.status_code == 409:
            raise ConflictError(pydantic.parse_obj_as(typing.Any, _response.json()))  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    async def update_a_status(
        self,
        target: PatchV2TargetIdentifierAttributesAttributeStatusesStatusRequestTarget,
        identifier: str,
        attribute: str,
        status: str,
        *,
        data: PatchV2TargetIdentifierAttributesAttributeStatusesStatusRequestData,
    ) -> PatchV2TargetIdentifierAttributesAttributeStatusesStatusResponse:
        """
        Update a status on an status attribute on either an object or a list.

        Required scopes: `object_configuration:read-write`.

        Parameters:
            - target: PatchV2TargetIdentifierAttributesAttributeStatusesStatusRequestTarget.

            - identifier: str.

            - attribute: str.

            - status: str.

            - data: PatchV2TargetIdentifierAttributesAttributeStatusesStatusRequestData.
        ---
        from attio import (
            PatchV2TargetIdentifierAttributesAttributeStatusesStatusRequestData,
            PatchV2TargetIdentifierAttributesAttributeStatusesStatusRequestTarget,
        )
        from attio.client import AsyncAttioClient

        client = AsyncAttioClient(
            token="YOUR_TOKEN",
        )
        await client.attributes.update_a_status(
            target=PatchV2TargetIdentifierAttributesAttributeStatusesStatusRequestTarget.LISTS,
            identifier="33ebdbe9-e529-47c9-b894-0ba25e9c15c0",
            attribute="41252299-f8c7-4b5e-99c9-4ff8321d2f96",
            status="In Progress",
            data=PatchV2TargetIdentifierAttributesAttributeStatusesStatusRequestData(
                title="In Progress",
                celebration_enabled=True,
                target_time_in_status="P0Y0M1DT0H0M0S",
                is_archived=False,
            ),
        )
        """
        _response = await self._client_wrapper.httpx_client.request(
            "PATCH",
            urllib.parse.urljoin(
                f"{self._client_wrapper.get_base_url()}/",
                f"v2/{target}/{identifier}/attributes/{attribute}/statuses/{status}",
            ),
            json=jsonable_encoder({"data": data}),
            headers=self._client_wrapper.get_headers(),
            timeout=60,
        )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(PatchV2TargetIdentifierAttributesAttributeStatusesStatusResponse, _response.json())  # type: ignore
        if _response.status_code == 400:
            raise BadRequestError(pydantic.parse_obj_as(typing.Any, _response.json()))  # type: ignore
        if _response.status_code == 404:
            raise NotFoundError(pydantic.parse_obj_as(typing.Any, _response.json()))  # type: ignore
        if _response.status_code == 409:
            raise ConflictError(pydantic.parse_obj_as(typing.Any, _response.json()))  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)
