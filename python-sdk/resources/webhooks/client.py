# This file was auto-generated by Fern from our API Definition.

import typing
import urllib.parse
from json.decoder import JSONDecodeError

from ...core.api_error import ApiError
from ...core.client_wrapper import AsyncClientWrapper, SyncClientWrapper
from ...core.jsonable_encoder import jsonable_encoder
from ...core.remove_none_from_dict import remove_none_from_dict
from ...errors.bad_request_error import BadRequestError
from ...errors.not_found_error import NotFoundError
from .types.delete_v_2_webhooks_webhook_id_response import DeleteV2WebhooksWebhookIdResponse
from .types.get_v_2_webhooks_response import GetV2WebhooksResponse
from .types.get_v_2_webhooks_webhook_id_response import GetV2WebhooksWebhookIdResponse
from .types.patch_v_2_webhooks_webhook_id_request_data import PatchV2WebhooksWebhookIdRequestData
from .types.patch_v_2_webhooks_webhook_id_response import PatchV2WebhooksWebhookIdResponse
from .types.post_v_2_webhooks_request_data import PostV2WebhooksRequestData
from .types.post_v_2_webhooks_response import PostV2WebhooksResponse

try:
    import pydantic as pydantic  # type: ignore
except ImportError:
    import pydantic  # type: ignore

# this is used as the default value for optional parameters
OMIT = typing.cast(typing.Any, ...)


class WebhooksClient:
    def __init__(self, *, client_wrapper: SyncClientWrapper):
        self._client_wrapper = client_wrapper

    def list_webhooks(
        self, *, limit: typing.Optional[int] = None, offset: typing.Optional[int] = None
    ) -> GetV2WebhooksResponse:
        """
        Get all of the webhooks in your workspace.

        Required scopes: `webhook:read`.

        Parameters:
            - limit: typing.Optional[int].

            - offset: typing.Optional[int].
        ---
        from attio.client import attio_api

        client = attio_api(
            token="YOUR_TOKEN",
        )
        client.webhooks.list_webhooks(
            limit=1,
            offset=1,
        )
        """
        _response = self._client_wrapper.httpx_client.request(
            "GET",
            urllib.parse.urljoin(f"{self._client_wrapper.get_base_url()}/", "v2/webhooks"),
            params=remove_none_from_dict({"limit": limit, "offset": offset}),
            headers=self._client_wrapper.get_headers(),
            timeout=60,
        )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(GetV2WebhooksResponse, _response.json())  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    def create_a_webhook(self, *, data: PostV2WebhooksRequestData) -> PostV2WebhooksResponse:
        """
        Create a webhook and associated subscriptions.

        Required scopes: `webhook:read-write`.

        Parameters:
            - data: PostV2WebhooksRequestData.
        ---
        from attio import (
            PostV2WebhooksRequestData,
            PostV2WebhooksRequestDataSubscriptionsItem,
            PostV2WebhooksRequestDataSubscriptionsItemEventType,
        )
        from attio.client import attio_api

        client = attio_api(
            token="YOUR_TOKEN",
        )
        client.webhooks.create_a_webhook(
            data=PostV2WebhooksRequestData(
                target_url="https://example.com/webhook",
                subscriptions=[
                    PostV2WebhooksRequestDataSubscriptionsItem(
                        event_type=PostV2WebhooksRequestDataSubscriptionsItemEventType.COMMENT_CREATED,
                    )
                ],
            ),
        )
        """
        _response = self._client_wrapper.httpx_client.request(
            "POST",
            urllib.parse.urljoin(f"{self._client_wrapper.get_base_url()}/", "v2/webhooks"),
            json=jsonable_encoder({"data": data}),
            headers=self._client_wrapper.get_headers(),
            timeout=60,
        )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(PostV2WebhooksResponse, _response.json())  # type: ignore
        if _response.status_code == 400:
            raise BadRequestError(pydantic.parse_obj_as(typing.Any, _response.json()))  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    def get_a_webhook(self, webhook_id: str) -> GetV2WebhooksWebhookIdResponse:
        """
        Get a single webhook.

        Required scopes: `webhook:read`.

        Parameters:
            - webhook_id: str.
        ---
        from attio.client import attio_api

        client = attio_api(
            token="YOUR_TOKEN",
        )
        client.webhooks.get_a_webhook(
            webhook_id="23e42eaf-323a-41da-b5bb-fd67eebda553",
        )
        """
        _response = self._client_wrapper.httpx_client.request(
            "GET",
            urllib.parse.urljoin(f"{self._client_wrapper.get_base_url()}/", f"v2/webhooks/{webhook_id}"),
            headers=self._client_wrapper.get_headers(),
            timeout=60,
        )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(GetV2WebhooksWebhookIdResponse, _response.json())  # type: ignore
        if _response.status_code == 404:
            raise NotFoundError(pydantic.parse_obj_as(typing.Any, _response.json()))  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    def delete_a_webhook(self, webhook_id: str) -> DeleteV2WebhooksWebhookIdResponse:
        """
        Delete a webhook by ID.

        Required scopes: `webhook:read-write`.

        Parameters:
            - webhook_id: str.
        ---
        from attio.client import attio_api

        client = attio_api(
            token="YOUR_TOKEN",
        )
        client.webhooks.delete_a_webhook(
            webhook_id="23e42eaf-323a-41da-b5bb-fd67eebda553",
        )
        """
        _response = self._client_wrapper.httpx_client.request(
            "DELETE",
            urllib.parse.urljoin(f"{self._client_wrapper.get_base_url()}/", f"v2/webhooks/{webhook_id}"),
            headers=self._client_wrapper.get_headers(),
            timeout=60,
        )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(DeleteV2WebhooksWebhookIdResponse, _response.json())  # type: ignore
        if _response.status_code == 404:
            raise NotFoundError(pydantic.parse_obj_as(typing.Any, _response.json()))  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    def update_a_webhook(
        self, webhook_id: str, *, data: PatchV2WebhooksWebhookIdRequestData
    ) -> PatchV2WebhooksWebhookIdResponse:
        """
        Update a webhook and associated subscriptions.

        Required scopes: `webhook:read-write`.

        Parameters:
            - webhook_id: str.

            - data: PatchV2WebhooksWebhookIdRequestData.
        ---
        from attio import (
            PatchV2WebhooksWebhookIdRequestData,
            PatchV2WebhooksWebhookIdRequestDataSubscriptionsItem,
            PatchV2WebhooksWebhookIdRequestDataSubscriptionsItemEventType,
        )
        from attio.client import attio_api

        client = attio_api(
            token="YOUR_TOKEN",
        )
        client.webhooks.update_a_webhook(
            webhook_id="23e42eaf-323a-41da-b5bb-fd67eebda553",
            data=PatchV2WebhooksWebhookIdRequestData(
                target_url="https://example.com/webhook",
                subscriptions=[
                    PatchV2WebhooksWebhookIdRequestDataSubscriptionsItem(
                        event_type=PatchV2WebhooksWebhookIdRequestDataSubscriptionsItemEventType.COMMENT_CREATED,
                    )
                ],
            ),
        )
        """
        _response = self._client_wrapper.httpx_client.request(
            "PATCH",
            urllib.parse.urljoin(f"{self._client_wrapper.get_base_url()}/", f"v2/webhooks/{webhook_id}"),
            json=jsonable_encoder({"data": data}),
            headers=self._client_wrapper.get_headers(),
            timeout=60,
        )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(PatchV2WebhooksWebhookIdResponse, _response.json())  # type: ignore
        if _response.status_code == 404:
            raise NotFoundError(pydantic.parse_obj_as(typing.Any, _response.json()))  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)


class AsyncWebhooksClient:
    def __init__(self, *, client_wrapper: AsyncClientWrapper):
        self._client_wrapper = client_wrapper

    async def list_webhooks(
        self, *, limit: typing.Optional[int] = None, offset: typing.Optional[int] = None
    ) -> GetV2WebhooksResponse:
        """
        Get all of the webhooks in your workspace.

        Required scopes: `webhook:read`.

        Parameters:
            - limit: typing.Optional[int].

            - offset: typing.Optional[int].
        ---
        from attio.client import Asyncattio_api

        client = Asyncattio_api(
            token="YOUR_TOKEN",
        )
        await client.webhooks.list_webhooks(
            limit=1,
            offset=1,
        )
        """
        _response = await self._client_wrapper.httpx_client.request(
            "GET",
            urllib.parse.urljoin(f"{self._client_wrapper.get_base_url()}/", "v2/webhooks"),
            params=remove_none_from_dict({"limit": limit, "offset": offset}),
            headers=self._client_wrapper.get_headers(),
            timeout=60,
        )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(GetV2WebhooksResponse, _response.json())  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    async def create_a_webhook(self, *, data: PostV2WebhooksRequestData) -> PostV2WebhooksResponse:
        """
        Create a webhook and associated subscriptions.

        Required scopes: `webhook:read-write`.

        Parameters:
            - data: PostV2WebhooksRequestData.
        ---
        from attio import (
            PostV2WebhooksRequestData,
            PostV2WebhooksRequestDataSubscriptionsItem,
            PostV2WebhooksRequestDataSubscriptionsItemEventType,
        )
        from attio.client import Asyncattio_api

        client = Asyncattio_api(
            token="YOUR_TOKEN",
        )
        await client.webhooks.create_a_webhook(
            data=PostV2WebhooksRequestData(
                target_url="https://example.com/webhook",
                subscriptions=[
                    PostV2WebhooksRequestDataSubscriptionsItem(
                        event_type=PostV2WebhooksRequestDataSubscriptionsItemEventType.COMMENT_CREATED,
                    )
                ],
            ),
        )
        """
        _response = await self._client_wrapper.httpx_client.request(
            "POST",
            urllib.parse.urljoin(f"{self._client_wrapper.get_base_url()}/", "v2/webhooks"),
            json=jsonable_encoder({"data": data}),
            headers=self._client_wrapper.get_headers(),
            timeout=60,
        )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(PostV2WebhooksResponse, _response.json())  # type: ignore
        if _response.status_code == 400:
            raise BadRequestError(pydantic.parse_obj_as(typing.Any, _response.json()))  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    async def get_a_webhook(self, webhook_id: str) -> GetV2WebhooksWebhookIdResponse:
        """
        Get a single webhook.

        Required scopes: `webhook:read`.

        Parameters:
            - webhook_id: str.
        ---
        from attio.client import Asyncattio_api

        client = Asyncattio_api(
            token="YOUR_TOKEN",
        )
        await client.webhooks.get_a_webhook(
            webhook_id="23e42eaf-323a-41da-b5bb-fd67eebda553",
        )
        """
        _response = await self._client_wrapper.httpx_client.request(
            "GET",
            urllib.parse.urljoin(f"{self._client_wrapper.get_base_url()}/", f"v2/webhooks/{webhook_id}"),
            headers=self._client_wrapper.get_headers(),
            timeout=60,
        )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(GetV2WebhooksWebhookIdResponse, _response.json())  # type: ignore
        if _response.status_code == 404:
            raise NotFoundError(pydantic.parse_obj_as(typing.Any, _response.json()))  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    async def delete_a_webhook(self, webhook_id: str) -> DeleteV2WebhooksWebhookIdResponse:
        """
        Delete a webhook by ID.

        Required scopes: `webhook:read-write`.

        Parameters:
            - webhook_id: str.
        ---
        from attio.client import Asyncattio_api

        client = Asyncattio_api(
            token="YOUR_TOKEN",
        )
        await client.webhooks.delete_a_webhook(
            webhook_id="23e42eaf-323a-41da-b5bb-fd67eebda553",
        )
        """
        _response = await self._client_wrapper.httpx_client.request(
            "DELETE",
            urllib.parse.urljoin(f"{self._client_wrapper.get_base_url()}/", f"v2/webhooks/{webhook_id}"),
            headers=self._client_wrapper.get_headers(),
            timeout=60,
        )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(DeleteV2WebhooksWebhookIdResponse, _response.json())  # type: ignore
        if _response.status_code == 404:
            raise NotFoundError(pydantic.parse_obj_as(typing.Any, _response.json()))  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    async def update_a_webhook(
        self, webhook_id: str, *, data: PatchV2WebhooksWebhookIdRequestData
    ) -> PatchV2WebhooksWebhookIdResponse:
        """
        Update a webhook and associated subscriptions.

        Required scopes: `webhook:read-write`.

        Parameters:
            - webhook_id: str.

            - data: PatchV2WebhooksWebhookIdRequestData.
        ---
        from attio import (
            PatchV2WebhooksWebhookIdRequestData,
            PatchV2WebhooksWebhookIdRequestDataSubscriptionsItem,
            PatchV2WebhooksWebhookIdRequestDataSubscriptionsItemEventType,
        )
        from attio.client import Asyncattio_api

        client = Asyncattio_api(
            token="YOUR_TOKEN",
        )
        await client.webhooks.update_a_webhook(
            webhook_id="23e42eaf-323a-41da-b5bb-fd67eebda553",
            data=PatchV2WebhooksWebhookIdRequestData(
                target_url="https://example.com/webhook",
                subscriptions=[
                    PatchV2WebhooksWebhookIdRequestDataSubscriptionsItem(
                        event_type=PatchV2WebhooksWebhookIdRequestDataSubscriptionsItemEventType.COMMENT_CREATED,
                    )
                ],
            ),
        )
        """
        _response = await self._client_wrapper.httpx_client.request(
            "PATCH",
            urllib.parse.urljoin(f"{self._client_wrapper.get_base_url()}/", f"v2/webhooks/{webhook_id}"),
            json=jsonable_encoder({"data": data}),
            headers=self._client_wrapper.get_headers(),
            timeout=60,
        )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(PatchV2WebhooksWebhookIdResponse, _response.json())  # type: ignore
        if _response.status_code == 404:
            raise NotFoundError(pydantic.parse_obj_as(typing.Any, _response.json()))  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)
